import { BaseEvent } from './event';
import { debounce, Events } from './util';

const SLICE_EVENT = 'slice';

const keys = {
  total: undefined,
  itemHeight: undefined,
  pad: undefined
};

export type Keys = keyof typeof keys;

const keyList: Keys[] = Object.values(keys);
export class AutoWcScroll extends HTMLElement {
  static tag = 'wc-scroll';
  constructor() {
    // ÂøÖÈ°ªÈ¶ñÂÖàË∞ÉÁî® super ÊñπÊ≥ï, ÁªßÊâøÂü∫Á±ª
    super();

    // ÂàùÂßãÂåñweb component
    this.init();
  }

  shadow: ShadowRoot;
  wrapper: HTMLElement;
  list: HTMLElement;
  slotEl: HTMLSlotElement;
  memoHeight = new Map<number, number>();
  padStart = 0;
  padEnd = 0;
  // memoStart: number;
  // memoEnd: number;
  memo = {
    start:0,
    end: 0,
    padStart:0,
    padEnd: 0,
  };

  /*----------------- ÈúÄËÆ°ÁÆóÁöÑÂ±ûÊÄß -----------------*/
  /** Ê∏≤ÊüìËµ∑Âßã‰ΩçÁΩÆ */
  start = 0;
  /** Ê∏≤ÊüìÁªàÊ≠¢‰ΩçÁΩÆ */
  end = 0;
  /** ÂÜÖÂÆπÈ´òÂ∫¶ */
  get expectPlaceholderHeight() {
    const itemHeight = this.getProp('itemHeight');
    const total = this.getProp('total');
    return itemHeight * total;
  }
  /** ÂØπÂä®ÊÄÅÈ´òÂ∫¶ÁöÑËÆ°ÁÆó */
  wrapperHeight: number;
  /*----------------- ÈúÄËÆ°ÁÆóÁöÑÂ±ûÊÄß -----------------*/
  e = new BaseEvent();
  #data: any[];
  template = document.createElement(`template`);

  /** append ü™ù */
  connectedCallback() {
    console.log('Â∑≤ÂàõÂª∫');
    const id = this.attributes.getNamedItem('id')?.value;
    this.watchDoms();
    Events.emit('init', id, this);
    const total = this.attributes.getNamedItem('total')?.value;
    this.calcList(total);
  }

  /** setAttribute Âíå innerHTML ü™ù */
  attributeChangedCallback(name, _, newValue) {
    if (name === 'total') {
      this.calcList(newValue);
    }
  }

  onSlice = (fn: (pos: { start: number; end: number }) => void) => {
    this.e.on(SLICE_EVENT, fn);
  };

  disconnectedCallback() {
    console.log('disconnectedCallback.');
  }
  adoptedCallback() {
    console.log('adoptedCallback.');
  }

  init() {
    this.template.innerHTML = `
      <style>
        :host {
          display: block;
        }
      </style>
      <div id="wrapper" style="overflow: hidden; position: relative; width: 100%; height: 100%">
        <div id="list" style="position: absolute; left: 0; top: 0; right: 0;">
          <slot id="slot"></slot>
        </div>
      </div>
    `;
    this.shadow = this.attachShadow({ mode: 'open' });
    this.shadow.appendChild(this.template['content'].cloneNode(true));
    // ËøòÂèØÁî®‰∫ã‰ª∂ÁõëÂê¨Êù•ÂÆûÁé∞
    this.e.on(SLICE_EVENT, detail => {
      const event = new CustomEvent(SLICE_EVENT, { detail });
      this.dispatchEvent(event);
    });
    window['ins'] = this;
  }

  addEventListener(
    type: string,
    listener: EventListenerOrEventListenerObject,
    options?: boolean | EventListenerOptions
  ): void {
    super.addEventListener(type, listener, options);
    if (type === SLICE_EVENT && this.isConnected) {
      const pos = this.createPos();
      const event = new CustomEvent(SLICE_EVENT, { detail: pos });
      this.dispatchEvent(event);
    }
  }

  watchDoms() {
    this.wrapper = this.shadow.getElementById('wrapper');
    window['wrapper'] = this.wrapper;
    this.list = this.shadow.getElementById('list');
    this.slotEl = this.shadow.getElementById('slot') as any;
    this.wrapperHeight = this.wrapper.offsetHeight;
    this.observer.observe(this.wrapper);
    this.wrapper.addEventListener('wheel', this.onWheel);
  }

  watchResize = debounce<ResizeObserverCallback>(function (this: AutoWcScroll, entries) {
    for (const entry of entries) {
      if (entry.target === this.wrapper) {
        const itemHeight = this.getProp('itemHeight');
        const height = entry.contentRect.height;
        this.wrapperHeight = height;
        // ‰∏ãÊãâÈ´òÂ∫¶Ë∂ÖËøá‰∫ÜÂΩìÂâçÊ∏≤ÊüìÂÜÖÂÆπÁöÑÈ´òÂ∫¶ÔºåÂàôÁ¥ßÊÄ•Ë°•‰∏äÔºå Ê≥®ÊÑè renderCount ‰æùËµñ wrapperHeightÔºå‰∏çËÉΩÊèêÂâçÊõ¥Êñ∞ wrapperHeight
        // if (height > (this.renderCount - 1) * itemHeight) {
        //   this.wrapperHeight = height;
        //   this.emitSliceAndFix();
        // } else {
        //   this.wrapperHeight = height;
        // }
      }
    }
  }, 300);

  emitSliceAndFix() {
    const pos = this.createPos();
    this.e.emit(SLICE_EVENT, pos);
  }
  createPos = () => {
    const that = this;
    const start = that.padStart;
    const end = that.padEnd;
    const pos = {
      get start() {
        if (!this.filed) {
          requestAnimationFrame(that.fix);
          this.filed = true;
        }
        return start;
      },
      end: end,
      filed: false
    };
    return pos;
  };
  sTop = 0;
  /** ÊªöÂä®Ëß¶ÂèëÊó∂ÁöÑ delta */
  deltaTop = 0;
  startItem = {
    height: 0,
    /** Ë¢´ÊªöÂä®ËøáÁöÑÂå∫Âüü */
    scrolled: 0
  };
  RATE = 0.5;
  onWheel = (e: WheelEvent) => {
    const scrolled = this.startItem.scrolled;
    const pad = this.getProp('pad');
    const total = this.getProp('total');
    let dtY = e.deltaY * this.RATE;
    const { minDtY, maxDtY } = this;
    // TODO: Ë°•ÂÖÖ startPad
    dtY = Math.min(Math.max(minDtY, dtY), maxDtY);
    

    this.sTop += dtY;

    // Âêë‰∏ãÊªëÂä®
    if (dtY >= 0) {
      const { end: start = 0, remain, overflow } = this.calcEnd(this.memo.start, scrolled + dtY);
      const screen = remain + this.wrapperHeight;
      const { end = total } = this.calcEnd(start, screen);
 
      this.overflow = overflow;
      this.start = start;
      this.padStart = nature(start - pad);
      this.end = end;
      this.padEnd = Math.min(this.end + pad + 1, total);
      this.emitSliceAndFix();
      return;
    }

    const preOverflow = this.overflow;
    //  Âêë‰∏äÊªëÂä®, remain Âíå overflow ÊòØÁõ∏ÂèçÁöÑÔºåoverflow Ë°®Á§∫Ë¢´ sTop ÈÅÆÁõñÁöÑÈÉ®ÂàÜÔºåremain Ë°®Á§∫Á¨¨‰∏ÄÈ°πÈú≤Âá∫ÁöÑÈÉ®ÂàÜ
    const { start=0, remain, overflow } = this.calcStart(this.memo.start, -dtY + preOverflow);
    // TODO: ÂÖ•ËøáÊñ∞ÁöÑÁ¨¨‰∏ÄÈ°πÊòØËôöÊãüÈ°πÔºåÁÆóÂá∫ÁöÑ end ‰ºö‰∏çÂáÜ
    const screen = overflow + this.wrapperHeight;
    const { end = total } = this.calcEnd(start, screen);
   
    this.overflow = remain;
    this.start = start;
    this.padStart = nature(start - pad);
    this.end = end;
    this.padEnd = Math.min(this.end + pad + 1, total);
    this.emitSliceAndFix();
    return;
  };

  overflow: number;
  minDtY: number;
  maxDtY: number;

  fix = () => {
    const total = this.getProp('total');
    const itemHeight = this.getProp('itemHeight');
    const items = this.slotEl.assignedElements();
    /** È¶ñÂ±è */
    const fp = this.overflow == null;

    this.memoHeight.clear();

    let renderHeight = 0;
    const startItemIdx = this.start - this.padStart
    this.startItem.height = items[startItemIdx]?.getBoundingClientRect().height || 0;
    /** ‰ªé scrollTop Âà∞ end ÁöÑË∑ùÁ¶ª */
    let topToPadEnd = 0;
    let padToTop = 0;
    for (let i = this.padStart, j = 0; i < this.padEnd; i++, j++) {
      const iRealHeight = items[j].getBoundingClientRect().height;
      renderHeight += iRealHeight;
      this.memoHeight.set(i, iRealHeight);
      if(i >= this.start) {
        topToPadEnd += i === this.start ? this.overflow ?? iRealHeight : iRealHeight;
      }
      if(i <= this.start) {
        padToTop += iRealHeight;
      }
    }
    this.renderHeight = renderHeight;
    this.memo = {
      padStart: this.padStart,
      padEnd: this.padEnd,
      start: this.start,
      end: this.end,
    }

    /**ÂèØÂêë‰∏ãÁßªÂä®ÁöÑÊúÄÂ§ßË∑ùÁ¶ª = ËßÜÂè£Â∫ïÈÉ® Âà∞ ÊÄªÂÜÖÂÆπÁöÑÊúÄÂêé‰∏ÄÈ°π
     * = (sTop Âà∞ ÊúÄÂêé‰∏ÄÈ°π) - ËßÜÂè£È´òÂ∫¶
     * = (sTop Âà∞ end) + (end Âà∞ ÊúÄÂêé‰∏ÄÈ°π) - ËßÜÂè£È´òÂ∫¶
     */
    const maxDtY = topToPadEnd + nature(total - this.padEnd) * itemHeight - this.wrapperHeight;
    this.maxDtY = maxDtY;

    /**
     * ÂèØÂêë‰∏äÁßªÂä®ÁöÑÊúÄÂ§ßË∑ùÁ¶ª = ËßÜÂè£È°∂ÈÉ® Âà∞ Á¨¨‰∏ÄÈ°πÈ°∂ÈÉ®
     * = [0, padStart) ËôöÊãüÈ°π + [padStart, start] ÁúüÂÆûÈ°π - overflowÔºõ
     * È¶ñÂ±è start È°πÁöÑ overflow ÊòØ‰∏ÄÊï¥È°π
     */
    const minDtY = -(this.padStart * itemHeight + padToTop - (this.overflow ?? this.startItem.height))
    this.minDtY = minDtY;
    // ÈùûÈ¶ñÂ±èËÆæÁΩÆÂÅèÁßªÈáè
    if (!fp) {
      const translateY = padToTop - this.overflow;
      this.startItem.scrolled = this.startItem.height - this.overflow;
      this.list.style.setProperty('transform', `translate3d(0,${-translateY}px,0)`);
    }
    console.log('-----------------------------------------------');

    console.log('fix', { maxDtY: this.maxDtY, minDtY: this.minDtY });
  };
  renderHeight = 0;

  calcList(totalStr: string) {
    try {
      const pad = this.getProp('pad');
      const total = this.getProp('total');
      // ÂàóË°®È´òÂ∫¶ ‰æùËµñ data
      const { end } = this.calcEnd(0, this.wrapperHeight);
      this.end = Math.min(end + 1, total);
      this.padEnd = Math.min(end + pad + 1, total);
      this.emitSliceAndFix();
    } catch (error) {
      console.log('totalÊú™ËÆæÁΩÆÂÄº', totalStr, error);
    }
  }
  /**
   * TODO: ËÆ°ÁÆó
   * ËÆ°ÁÆó‰ªéÊüê‰ΩçÁΩÆÂºÄÂßãÔºåÈúÄË¶ÅÂá†È°πËÉΩÂ°´Êª°ÁõÆÊ†áÈ´òÂ∫¶
   */
  calcStart = (from: number, tHeight: number) => {
    const itemHeight = this.getProp('itemHeight');
    let i = from;
    /** Ëøô‰∏ÄÈ°πÂàöÂ•ΩÂ°´Êª° */
    let start: number;
    let remain: number;
    let overflow: number;

    while (0 <= i) {
      // Âú®Ê≠§Âå∫Èó¥ËÉΩÊãøÂà∞ÁúüÂÆûÈ´òÂ∫¶
      if (i >= this.memo.padStart && i < this.memo.padEnd) {
        const realHeight = this.memoHeight.get(i);
        if (realHeight >= tHeight) {
          overflow = realHeight - tHeight;
          remain = tHeight;
          start = i;
          break;
        } else {
          tHeight -= realHeight;
        }
        i--;
        continue;
      }

      if (i < this.memo.padStart) {
        // [0, i] ÊòØËôöÊãüÈ°π
        const virtualCount = i + 1;
        // ÈúÄË¶Å x È°πÂ°´Êª°
        const x = Math.ceil(tHeight / itemHeight);
        if (virtualCount >= x) {
          overflow = x * itemHeight - tHeight;
          remain = itemHeight - overflow;
          start = i - x + 1;
          break;
        }
        // ‰∏çÂ§üÂ°´Êª°
        else {
          tHeight -= virtualCount * itemHeight;
        }
        i = -1;
        continue;
      }

      //  this.memo.padEnd <= i
      // [this.memo.padEnd, i] ÊòØËôöÊãüÈ°π
      const virtualCount = i + 1 - this.memo.padEnd;
      // ÈúÄË¶Å x È°πÂ°´Êª°
      const x = Math.ceil(tHeight / itemHeight);
      if (virtualCount >= x) {
        overflow = x * itemHeight - tHeight;
        remain = itemHeight - overflow;
        start = i - x + 1;
        break;
      }
      // ‰∏çÂ§üÂ°´Êª°
      else {
        tHeight -= virtualCount * itemHeight;
      }
      i = this.memo.padEnd - 1;
    }

    return {
      // end Âê´ -1ËÆ°ÁÆóÔºåÊï∞ÁªÑÈïøÂ∫¶ÊûÅÁ´ØÊÉÖÂÜµÈúÄË¶ÅÊõ¥Êîπ
      start: start == null ? start : nature(start),
      overflow,
      remain
    };
  };
  calcEnd = (from: number, tHeight: number) => {
    const total = this.getProp('total');
    const itemHeight = this.getProp('itemHeight');
    let i = from;
    /** Ëøô‰∏ÄÈ°πÂàöÂ•ΩÂ°´Êª° */
    let end: number;
    let remain: number;
    let overflow: number;

    while (i < total) {
      // Âú®Ê≠§Âå∫Èó¥ËÉΩÊãøÂà∞ÁúüÂÆûÈ´òÂ∫¶
      if (i >= this.memo.padStart && i < this.memo.padEnd) {
        const realHeight = this.memoHeight.get(i);
        if (realHeight >= tHeight) {
          overflow = realHeight - tHeight;
          remain = tHeight;
          end = i;
          break;
        } else {
          tHeight -= realHeight;
        }
        i++;
        continue;
      }

      if (i < this.memo.padStart) {
        // [i, this.memo.padStart) ÊòØËôöÊãüÈ°π
        const virtualCount = this.memo.padStart - i;
        // ÈúÄË¶Å x È°πÂ°´Êª°
        const x = Math.ceil(tHeight / itemHeight);
        // Ë∂≥Â§üÂ°´Êª°Ôºö i=0, x = 2; i+x=2 => [0,1,2]ÊòØ3È°π‚ùå; i+x-1=1 => [0,1]‚úÖ
        if (virtualCount >= x) {
          overflow = x * itemHeight - tHeight;
          remain = itemHeight - overflow;
          end = i + x - 1;
          break;
        }
        // ‰∏çÂ§üÂ°´Êª°
        else {
          tHeight -= virtualCount * itemHeight;
        }
        i = this.memo.padStart;
        continue;
      }

      // this.memoEnd <= i
      // [i, total) ÊòØËôöÊãüÈ°π
      const virtualCount = total - i;
      // ÈúÄË¶Å x È°πÂ°´Êª°
      const x = Math.ceil(tHeight / itemHeight);
      // Ë∂≥Â§üÂ°´Êª°Ôºö i=0, x = 2; i+x=2 => [0,1,2]ÊòØ3È°π‚ùå; i+x-1=1 => [0,1]‚úÖ
      if (virtualCount >= x) {
        overflow = x * itemHeight - tHeight;
        remain = itemHeight - overflow;
        end = i + x - 1;
        break;
      }
      // ‰∏çÂ§üÂ°´Êª°
      else {
        tHeight -= virtualCount * itemHeight;
      }
      i = total;
    }

    return {
      // end Âê´ -1ËÆ°ÁÆóÔºåÊï∞ÁªÑÈïøÂ∫¶ÊûÅÁ´ØÊÉÖÂÜµÈúÄË¶ÅÊõ¥Êîπ
      end: end == null ? end : Math.max(end, 0),
      overflow,
      remain
    };
  };

  getProp(key: Keys) {
    try {
      return Number(this.attributes.getNamedItem(key).value);
    } catch (error) {
      throw {
        message: `Êú™‰º†ÂÖ•Â±ûÊÄß${key}!`,
        raw: error
      };
    }
  }
  // TODO: ÈîÄÊØÅÊó∂ÂèñÊ∂àÊâÄÊúâÁõëÂê¨Âô®
  observer = new ResizeObserver(this.watchResize.bind(this));
}


function nature (num: number) {
  return Math.max(num, 0);
}